### 实践-TCC模式



**TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：**

**•Try：资源的检测和预留；** 

**•Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。**

**Cancel：预留资源释放，可以理解为try的反向操作。**



![Tcc](E:\笔记整理\微服务技术\seata\图片\Tcc.png)





![Tcc模型](E:\笔记整理\微服务技术\seata\图片\Tcc模型.png)



**TCC模式的每个阶段是做什么的？**

**•Try：资源检查和预留**

**•Confirm：业务执行和提交**

**•Cancel：预留资源的释放**



**TCC的优点是什么？**

**•一阶段完成直接提交事务，释放数据库资源，性能好**

**•相比AT模型，无需生成快照，无需使用全局锁，性能最强**

**•不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库**



**TCC的缺点是什么？**

**•有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦**

**•软状态，事务是最终一致**

**需要考虑Confirm和Cancel的失败情况，做好幂等处理**





### 问题：

![TCC问题](E:\笔记整理\微服务技术\seata\图片\TCC问题.png)

**空回滚：网络阻塞，事务一已经执行，事务二卡住了，TM认为失败，TC通知全部回滚，实际上事务二还没执行**

**我们就需要让事务二空回滚，也就是自己编写代码执行无效的操作**



**业务悬挂：网络恢复正常，事务二开始try操作，但是这一个全局事务已经执行，后续就不会再执行confirm和**

**cancel了，我们应该在try的时候把他拦截，自己做判断中断try的执行**



### 使用：



#### 声明TCC接口

**TCC的Try、Confirm、Cancel方法都需要在接口中基于注解来声明，语法如下：**



![使用](E:\笔记整理\微服务技术\seata\图片\使用.png)