### Zookeeper分布式锁



**在单机进行开发的时候，设计同步异步的时候，我们一般使用synchronized或者lock来解决代码同步问题**

**这个时候多线程运行在一个JVM，不会有问题**

**但是在分布式的环境，使用以上的方法就会出现问题了，因为你的锁只对本机的JVM生效，对其他无效**

**这个时候，就需要一种更高级的锁，能够跨JVM，跨机器的数据同步锁-------->分布式锁**



**1：redis实现【性能非常高，但是安全性不太可靠】**

**2：zookeeper实现【性能相对较高，安全性高】**

**3：数据库层面实现【性能低】**





#### 分布式锁原理

**核心：客户端要获取锁，则创建节点。使用完锁，就删除该节点**



#### **1：客户端获取锁的时候，在节点下创建【临时顺序】节点**

**假如有三个客户端，则创建了三个【临时顺序节点】**

**假设创建了lock/1    lock/2   lock/3**

**为什么是临时节点呢？因为客户端使用完，或者客户端宕机了，那么服务端就会消除那个锁，其他客户端才能使用**

**为什么是顺序呢？因为后面要排序，找最小节点，拿锁，而且要找比自己小的一个锁并监听删除事件**



#### **2：然后获取节点下的所有子节点，客户端获取到所有的子节点之后，如果发现自己的节点序号最小，那么就认为该客户端获得了锁，使用完锁之后，删除节点**



#### 3：如果发现自己并不是节点中最小的，说明自己没有获得锁，然后客户端需要找到比自己小的那个节点，同时对其注册事件监听，监听删除事件

**lock2监听lock1的删除事件     lock3监听lock2的删除事件    lock1被删除，lock3不会受到通知**  



#### 4：如果发现比自己小的节点被删除，则客户端的watch会收到通知，再次判断自己的节点是不是最小的，如果是则获取锁，如果不是自己最小，则继续获取比自己小的那个节点，并继续注册删除事件